---
globs: ['**/utils/validation.ts', '**/types/**/*.ts']
exclude: ['**/__tests__/**', '**/*.test.*', '**/*.spec.*']
---

# Validation System Standards

## Overview

RandoDrum implements a comprehensive validation system using Zod that provides both runtime validation and TypeScript type inference. The system ensures data integrity across the entire application.

## Core Principles

- **Schema-First Development**: Define Zod schemas first, then derive TypeScript types
- **Single Source of Truth**: Use Zod schemas as the authoritative source for validation rules
- **Type Safety**: Leverage Zod's type inference for compile-time type safety
- **Runtime Validation**: Ensure data integrity at runtime with comprehensive validation
- **Error Handling**: Provide meaningful error messages for validation failures

## Validation Architecture

```
src/utils/validation.ts
├── Basic Type Schemas          # Individual type validation
├── Complex Object Schemas      # Composite object validation
├── Type Inference Helpers      # TypeScript type derivation
├── Individual Validation       # Single-value validation functions
├── Complex Object Validation   # Multi-field validation functions
├── Safe Validation Functions   # Error-safe validation with results
└── Type Guards                 # Runtime type checking
```

## Available Schemas

### Basic Type Schemas

#### Difficulty Level Schema

```typescript
export const difficultyLevelSchema = z.enum(
	DIFFICULTY_LEVELS.map(level => level) as [string, ...string[]]
);
```

#### Duration Value Schema

```typescript
export const durationValueSchema = z.union([...DURATIONS.map(duration => z.literal(duration))]);
```

#### Dynamic Name Schema

```typescript
export const dynamicNameSchema = z.enum(DYNAMICS.map(dynamic => dynamic) as [string, ...string[]]);
```

#### Ornament Name Schema

```typescript
export const ornamentNameSchema = z.union([...ORNAMENTS.map(ornament => z.literal(ornament))]);
```

### Complex Object Schemas

#### Note Schema

```typescript
export const noteSchema = z.object({
	start: z.number().min(0), // Start time must be non-negative
	dur: durationValueSchema, // Duration must be valid grid value
	dynamic: dynamicNameSchema, // Dynamic must be valid level
	isDominant: z.boolean(), // Boolean for hand dominance
	ornament: ornamentNameSchema, // Ornament must be valid or null
});
```

#### Beat Form Data Schema

```typescript
export const beatFormDataSchema = z.object({
	beats: z.number().min(1).max(16).int(), // 1-16 beats per measure
	measures: z.number().min(1).max(32).int(), // 1-32 measures
	difficulty: difficultyLevelSchema, // Valid difficulty level
});
```

#### Generated Beat Schema

```typescript
export const generatedBeatSchema = z.object({
	measures: z.array(measureSchema), // Array of valid measures
	beatsPerMeasure: z.number().min(1).max(16).int(), // 1-16 beats per measure
	difficulty: difficultyLevelSchema, // Valid difficulty level
});
```

## Validation Functions

### Strict Validation Functions

Use these functions for internal data processing where invalid data should cause immediate failure:

```typescript
// Individual type validation
export const validateDifficultyLevel = (value: unknown): DifficultyLevel => {
	return difficultyLevelSchema.parse(value);
};

export const validateDurationValue = (value: unknown): DurationValue => {
	return durationValueSchema.parse(value);
};

// Complex object validation
export const validateBeatFormData = (data: unknown): ValidatedBeatFormData => {
	return beatFormDataSchema.parse(data);
};

export const validateGeneratedBeat = (data: unknown): ValidatedGeneratedBeat => {
	return generatedBeatSchema.parse(data);
};
```

### Safe Validation Functions

Use these functions for user input and external data where graceful error handling is preferred:

```typescript
export const safeValidateBeatFormData = (
	data: unknown
): { success: true; data: ValidatedBeatFormData } | { success: false; error: string } => {
	try {
		const validated = beatFormDataSchema.parse(data);
		return { success: true, data: validated };
	} catch (error) {
		if (error instanceof z.ZodError) {
			return {
				success: false,
				error: `Invalid beat form data: ${error.errors.map(e => e.message).join(', ')}`,
			};
		}
		return { success: false, error: 'Invalid beat form data format' };
	}
};
```

### Type Guards

Use these functions for runtime type checking without throwing errors:

```typescript
export const isBeatFormData = (data: unknown): data is ValidatedBeatFormData => {
	return beatFormDataSchema.safeParse(data).success;
};

export const isGeneratedBeat = (data: unknown): data is ValidatedGeneratedBeat => {
	return generatedBeatSchema.safeParse(data).success;
};
```

## Type Inference

The validation system provides comprehensive type inference from Zod schemas:

```typescript
// Type inference from schemas
export type ValidatedBeatFormData = z.infer<typeof beatFormDataSchema>;
export type ValidatedGeneratedBeat = z.infer<typeof generatedBeatSchema>;
export type ValidatedMeasure = z.infer<typeof measureSchema>;
export type ValidatedNote = z.infer<typeof noteSchema>;
```

## Integration Patterns

### Form Integration

```typescript
import { useForm } from '@tanstack/react-form';
import { beatFormDataSchema, type ValidatedBeatFormData } from '@/utils/validation';

const form = useForm<ValidatedBeatFormData>({
	defaultValues: {
		beats: 4,
		measures: 4,
		difficulty: 'Hey, Not Too Rough',
	},
	onSubmit: async ({ value }) => {
		// value is automatically typed as ValidatedBeatFormData
		const result = safeValidateBeatFormData(value);
		if (result.success) {
			// Process validated data
		} else {
			// Handle validation error
		}
	},
});
```

### API Integration

```typescript
import { validateGeneratedBeat } from '@/utils/validation';

export async function generateBeat(
	formData: ValidatedBeatFormData
): Promise<ValidatedGeneratedBeat> {
	const response = await fetch('/api/generate-beat', {
		method: 'POST',
		body: JSON.stringify(formData),
	});

	const data = await response.json();
	return validateGeneratedBeat(data); // Throws if invalid
}
```

### Store Integration

```typescript
import { create } from 'zustand';
import type { ValidatedGeneratedBeat } from '@/utils/validation';

interface BeatStore {
	currentBeat: ValidatedGeneratedBeat | null;
	setCurrentBeat: (beat: ValidatedGeneratedBeat) => void;
}

export const useBeatStore = create<BeatStore>(set => ({
	currentBeat: null,
	setCurrentBeat: beat => set({ currentBeat: beat }),
}));
```

## Best Practices

### Schema Design

1. **Start with Schemas**: Define Zod schemas first, then derive TypeScript types
2. **Comprehensive Validation**: Include all necessary validation rules in schemas
3. **Meaningful Error Messages**: Use custom error messages for better user experience
4. **Consistent Naming**: Use consistent naming patterns across schemas

### Validation Strategy

1. **Use Strict Validation for Internal Data**: Use functions that throw errors for internal data processing
2. **Use Safe Validation for User Input**: Use safe validation functions for user input and external data
3. **Use Type Guards for Conditional Logic**: Use type guards for runtime type checking
4. **Validate at Boundaries**: Validate data at system boundaries (API, forms, imports)

### Error Handling

1. **Provide Context**: Include context in error messages
2. **Handle Gracefully**: Use safe validation for user-facing operations
3. **Log Errors**: Log validation errors for debugging
4. **User-Friendly Messages**: Convert technical errors to user-friendly messages

## Testing

### Schema Testing

```typescript
import { describe, it, expect } from 'vitest';
import { beatFormDataSchema } from '@/utils/validation';

describe('beatFormDataSchema', () => {
	it('validates correct form data', () => {
		const validData = { beats: 4, measures: 4, difficulty: 'Hey, Not Too Rough' };
		expect(() => beatFormDataSchema.parse(validData)).not.toThrow();
	});

	it('rejects invalid form data', () => {
		const invalidData = { beats: 0, measures: 4, difficulty: 'Hey, Not Too Rough' };
		expect(() => beatFormDataSchema.parse(invalidData)).toThrow();
	});
});
```

### Validation Function Testing

```typescript
import { describe, it, expect } from 'vitest';
import { safeValidateBeatFormData } from '@/utils/validation';

describe('safeValidateBeatFormData', () => {
	it('returns success for valid data', () => {
		const validData = { beats: 4, measures: 4, difficulty: 'Hey, Not Too Rough' };
		const result = safeValidateBeatFormData(validData);
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data).toEqual(validData);
		}
	});

	it('returns error for invalid data', () => {
		const invalidData = { beats: 0, measures: 4, difficulty: 'Hey, Not Too Rough' };
		const result = safeValidateBeatFormData(invalidData);
		expect(result.success).toBe(false);
		if (!result.success) {
			expect(result.error).toContain('Invalid beat form data');
		}
	});
});
```

## Performance Considerations

### Schema Compilation

- Zod schemas are compiled once and reused
- Complex schemas may have higher compilation overhead
- Consider schema complexity vs. validation performance

### Validation Frequency

- Validate at system boundaries, not on every operation
- Use type guards for frequent type checking
- Cache validation results when appropriate

### Error Handling Overhead

- Safe validation has minimal overhead compared to strict validation
- Error message generation adds some overhead
- Consider error handling strategy based on performance requirements

## Configuration Validation

The system includes built-in validation for difficulty configurations to ensure logical consistency:

### Dynamic Scale Validation

```typescript
export const getDifficultyConfig = (difficulty: DifficultyLevel): DifficultyConfig => {
	const config = DIFFICULTY_CONFIGS[difficulty];
	if (!config) {
		throw new Error(`Unknown difficulty level: ${difficulty}`);
	}

	// Validate dynamicScale consistency
	const [normalThreshold, accentThreshold] = config.dynamicScale;
	if (normalThreshold > accentThreshold) {
		throw new Error(
			`Invalid dynamicScale for ${difficulty}: normalThreshold (${normalThreshold}) must be <= accentThreshold (${accentThreshold})`
		);
	}

	return config;
};
```

### Configuration Validation Function

```typescript
export const validateDifficultyConfigs = (): void => {
	for (const difficulty of DIFFICULTY_LEVELS) {
		try {
			getDifficultyConfig(difficulty);
		} catch (error) {
			throw new Error(
				`Configuration validation failed for ${difficulty}: ${error instanceof Error ? error.message : 'Unknown error'}`
			);
		}
	}
};
```

This validation ensures that:

- `normalThreshold <= accentThreshold` for logical dynamic selection
- All difficulty configurations are valid and consistent
- Errors are caught at module load time for immediate feedback

## Future Enhancements

### Custom Validators

```typescript
// Example: Custom validator for beat generation constraints
const beatGenerationValidator = z
	.object({
		beats: z.number().min(1).max(16).int(),
		measures: z.number().min(1).max(32).int(),
		difficulty: difficultyLevelSchema,
	})
	.refine(
		data => data.beats * data.measures <= 128, // Max total notes
		{
			message: 'Total notes (beats × measures) cannot exceed 128',
			path: ['beats', 'measures'],
		}
	);
```

### Async Validation

```typescript
// Example: Async validation for external data
const asyncBeatValidator = z
	.object({
		// ... schema definition
	})
	.refineAsync(
		async data => {
			// Check if beat is too complex for current system
			const complexity = await calculateBeatComplexity(data);
			return complexity < MAX_COMPLEXITY;
		},
		{
			message: 'Beat is too complex for current system',
		}
	);
```

The validation system provides a robust foundation for data integrity throughout the RandoDrum application, ensuring both type safety and runtime validation with comprehensive error handling and user-friendly error messages.
